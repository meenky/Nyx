#include <nyx/plugin.h>

#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

#include <stdlib.h>
#include <iostream>


using namespace nyx;


static inline lua_State *asState(void *L) {
  return reinterpret_cast<lua_State *>(L);
}


Plugin::Plugin(void *lua, const std::string &language):
  lang(language),
  L(lua) {
}


Plugin::~Plugin() {
  if(L) {
    lua_close(asState(L));
  }
}

std::shared_ptr<Plugin> Plugin::load(const Filesystem &fs,
                                    const std::string &lang,
                                    const std::vector<std::string> &opts) {
  std::string file("nyxlang-");

  if(auto path = fs.locate(file.append(lang).append(".lua"))) {
    if(auto lua = luaL_newstate()) {
      luaL_openlibs(lua);

      if(!luaL_dofile(lua, path->c_str())) {
        return std::shared_ptr<Plugin>(new Plugin(lua, lang));
      }
      else {
        std::cerr << "Error loading " << lang << " plugin: " << lua_tostring(lua, -1) << std::endl;
        lua_close(lua);
      }
    }
    else {
      std::cerr << "Unable to create plugin context" << std::endl;
    }
  }
  else {
    std::cerr << "Unable to locate plugin for " << lang << std::endl;
  }

  return nullptr;
}


int Plugin::execute(std::shared_ptr<Plan> plan) {
  std::string script("-- BEGIN AUTOGENERATED DATA\n");
  script.reserve(16384);
  script.append("plan = {\n");
  // TODO: turn plan into valid lua and add to the plugin
  script.append("  text = 'string value'\n");
  script.append("}\n");
  script.append(
    "-- END AUTOGENERATED DATA\n\n"
    // add in an extra function to aid in output
    "io.mkdir = function(path) os.execute(\"mkdir -p'\"..path..\"'\"); end\n"
    "execute(plan)\n"
  );

  if(luaL_dostring(asState(L), script.c_str())) {
    std::cerr << "Error running " << lang << " plugin: " << lua_tostring(asState(L), -1) << std::endl;
  }
  else if(!lua_tonumber(asState(L), -1)) {
    return EXIT_SUCCESS;
  }

  return EXIT_FAILURE;
}

